import * as fs from 'fs';
import { PDFDocument } from 'pdf-lib';
import * as pdfjsLib from 'pdfjs-dist';

/**
 * Core interfaces for the PDF Accessibility Checker
 */

/**
 * Represents a single accessibility issue found in a PDF document.
 * Each issue is tied to a specific WCAG criterion and includes details
 * about the problem and how to fix it.
 */
export interface AccessibilityIssue {
    /** The WCAG criterion that this issue violates (e.g., "1.1.1 Non-text Content") */
    criterion: string;
    
    /** Detailed description of the accessibility issue */
    description: string;
    
    /** Severity of the issue's impact on users with disabilities (e.g., "Critical", "Serious", "Moderate") */
    impact: string;
    
    /** Suggested steps to fix the accessibility issue */
    remediation: string;
}

/**
 * Represents a complete accessibility report for a PDF document.
 * Contains overall status and a list of all identified issues.
 */
export interface AccessibilityReport {
    /** Name of the PDF file that was analyzed */
    filename: string;
    
    /** Whether the document passed all accessibility checks */
    passed: boolean;
    
    /** List of all accessibility issues found in the document */
    issues: AccessibilityIssue[];
    
    /**
     * List of tests that are pending implementation or have not been run.
     * This is used to track progress on implementing additional accessibility checks.
     */
    pendingTests?: Array<{
        /** The WCAG criterion that this test covers (e.g., "2.4.5 Multiple Ways") */
        criterion: string;
        
        /** Reason why this test is pending (e.g., "In Progress - Requirements Gathering") */
        reason: string;
        
        /** Current status of the test implementation (e.g., "Planned", "In Progress", "Completed") */
        status?: string;
    }>;
    
    /**
     * Additional notes or comments about the accessibility of the document.
     * This can include explanations for pending tests or other relevant information.
     */
    additionalNotes?: string;
    
    /**
     * Information about the type of document (form or regular document) and the confidence level of this classification.
     */
    documentType?: {
        /** Whether the document is a form */
        isForm: boolean;
        
        /** Whether the document is a regular document (not a form) */
        isDocument: boolean;
        
        /** Confidence level (as a percentage) in the document type classification */
        confidence: number;
    };
    
    /** Timestamp when the accessibility report was generated */
    timestamp: string;
}

/**
 * Represents the content of a text element in a PDF document.
 * Includes the text itself, the page number, and information about language tags.
 */
export interface TextContent {
    /** The actual text content */
    text: string;
    
    /** Page number where this text is located */
    page: number;
    
    /**
     * Whether this text has a language tag in the PDF structure tree.
     * This indicates that the text has been explicitly marked with a language.
     */
    hasLangTag?: boolean;
    
    /**
     * Detected language of the text content (e.g., "en" for English, "fr" for French).
     * This is automatically detected based on the text content.
     */
    detectedLang?: string;
}

/**
 * Represents a link in a PDF document.
 * Includes the link text, URL, and page number.
 */
export interface LinkContent {
    /** The text displayed for the link */
    linkText: string;
    
    /** The URL that the link points to */
    url: string;
    
    /** Page number where this link is located */
    page: number;
}

/**
 * Represents an image in a PDF document.
 * Includes information about the image's alt text and page number.
 */
export interface ImageContent {
    /**
     * Whether the image has alt text in the PDF structure tree.
     * This indicates that the image has been explicitly marked with alternative text.
     */
    hasAltText: boolean;
    
    /**
     * The actual alt text for the image, if available.
     * This is the text that screen readers will announce for the image.
     */
    altText?: string;
    
    /** Page number where this image is located */
    page: number;
    
    /**
     * Unique identifier for the image in the PDF document.
     * This can be used to reference the image in other parts of the document.
     */
    id?: string;
}

/**
 * Represents a pending test that has not been implemented or run yet.
 * This is used to track progress on implementing additional accessibility checks.
 */
export interface PendingTest {
    /** The WCAG criterion that this test covers (e.g., "2.4.5 Multiple Ways") */
    criterion: string;
    
    /** Reason why this test is pending (e.g., "In Progress - Requirements Gathering") */
    reason: string;
    
    /** Current status of the test implementation (e.g., "Planned", "In Progress", "Completed") */
    status?: string;
}

/**
 * Represents the result of document type detection.
 * Includes flags indicating whether the document is a form or regular document,
 * along with a confidence level for this classification.
 */
export interface DocumentTypeResult {
    /** Whether the document is a form */
    isForm: boolean;
    
    /** Whether the document is a regular document (not a form) */
    isDocument: boolean;
    
    /** Confidence level (as a percentage) in the document type classification */
    confidence: number;
    
    /**
     * Additional details about the document type detection process.
     * This can include information about the algorithms used or any issues encountered.
     */
    details: string[];
}

/**
 * Class containing implementations of WCAG tests for PDF documents.
 * These tests cover various aspects of accessibility, including
 * title, language, link purpose, and image alt text.
 */
export class WcagTests {
    /**
     * Tests if a PDF document has a title in its metadata (WCAG 2.4.2)
     * @param pdfDoc PDF document
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testDocumentTitle(pdfDoc: pdfjsLib.PDFDocumentProxy): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            // Get the title from the PDF metadata
            const title = await PdfMetadataExtractor.extractTitle(pdfDoc);

            // If no title is found, return an accessibility issue
            if (!title) {
                return {
                    passed: false,
                    issue: IssueFactory.createIssue(
                        "WCAG 2.4.2 Page Titled (Level A)",
                        "PDF document does not have a title in its metadata",
                        "Screen readers cannot announce the document title, making it difficult for users to understand the document's purpose or distinguish between multiple open documents",
                        "Add a descriptive title to the PDF document's metadata properties"
                    )
                };
            }

            // Title exists, no issue
            return { passed: true };
        } catch (error) {
            console.error('Error testing PDF title:', error);
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    "WCAG 2.4.2 Page Titled (Level A)",
                    error as Error,
                    "Unable to determine if the document has a proper title",
                    "Ensure the PDF file is valid and accessible"
                )
            };
        }
    }

    /**
     * Tests if a PDF document has a language identifier in its metadata (WCAG 3.1.1)
     * @param pdfDoc PDF document
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testDocumentLanguage(pdfDoc: pdfjsLib.PDFDocumentProxy): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            // Check if there's metadata in the document
            const hasMetadata = await PdfMetadataExtractor.hasMetadata(pdfDoc);

            // If no metadata is found, return an accessibility issue
            if (!hasMetadata) {
                return {
                    passed: false,
                    issue: IssueFactory.createIssue(
                        "WCAG 3.1.1 Language of Page (Level A)",
                        "PDF document may not have a language identifier in its metadata",
                        "Screen readers may not be able to determine the document language, leading to incorrect pronunciation and potentially making content incomprehensible to users",
                        "Set the document language in the PDF properties"
                    )
                };
            }

            // Metadata exists, no issue
            return { passed: true };
        } catch (error) {
            console.error('Error testing PDF language:', error);
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    "WCAG 3.1.1 Language of Page (Level A)",
                    error as Error,
                    "Unable to determine if the document has a proper language identifier",
                    "Ensure the PDF file is valid and accessible"
                )
            };
        }
    }

    /**
     * Tests if all text in a PDF document has a language identifier (WCAG 3.1.2)
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testLanguageOfParts(pdfPath: string): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            // Load the PDF document
            const pdfDoc = await PdfLoader.loadWithPdfJs(pdfPath);
            
            // Extract all text content from the document
            const textContents: TextContent[] = [];
            let hasAnyText = false;
            let hasSubstantialText = false;

            // Process each page
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                
                // Extract text from the page
                const extractionResult = await TextExtractor.extractTextFromPage(page, pageNum);

                textContents.push(...extractionResult);
                hasAnyText = hasAnyText || extractionResult.some(item => item.text.trim());
                hasSubstantialText = hasSubstantialText || extractionResult.some(item => item.text.length > 10);
            }

            // If the document doesn't contain any substantial text, this criterion doesn't apply
            if (!hasSubstantialText) {
                console.log("Document doesn't contain substantial text, WCAG 3.1.2 criterion doesn't apply");
                return { passed: true };
            }

            // Check for text without language tags
            const textWithoutLangTags = textContents.filter(item =>
                item.detectedLang &&
                !item.hasLangTag &&
                // Additional check to ensure the text is substantial enough to warrant language detection
                item.text.length > 10
            );

            // If we found text without language tags
            if (textWithoutLangTags.length > 0) {
                return {
                    passed: false,
                    issue: IssueFactory.createIssue(
                        "WCAG 3.1.2 Language of Parts (Level AA)",
                        `PDF document contains text that may not have language tags. Found ${textWithoutLangTags.length} instances of substantial text without explicit language identification.`,
                        "Screen readers may not be able to determine the language of specific parts of the document, leading to incorrect pronunciation and potentially making content incomprehensible to users",
                        "Ensure that all text in the PDF has appropriate language tags, especially when the language changes within the document"
                    )
                };
            }

            // No issues found
            return { passed: true };
        } catch (error) {
            console.error('Error testing language of parts:', error);
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    "WCAG 3.1.2 Language of Parts (Level AA)",
                    error as Error,
                    "Unable to determine if all parts of the document have proper language identifiers",
                    "Ensure the PDF file is valid and accessible, with proper language tagging throughout"
                )
            };
        }
    }

    /**
     * Tests if links in a PDF document have a clear purpose (WCAG 2.4.4)
     * @param pdfDoc PDF document
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testLinkPurpose(pdfDoc: pdfjsLib.PDFDocumentProxy): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            // Extract link content from all pages
            const links: LinkContent[] = [];

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);

                // Extract links from the page
                const linkExtractionResult = await LinkExtractor.extractLinksFromPage(page, pageNum);

                links.push(...linkExtractionResult);
            }

            // Check for links with unclear purpose
            const unclearLinks = links.filter(link =>
                !link.linkText ||
                link.linkText.trim().length < 5 ||
                link.linkText.toLowerCase().includes('http') ||
                link.linkText.toLowerCase().includes('www')
            );

            // If we found links with unclear purpose
            if (unclearLinks.length > 0) {
                // Get examples of the problematic links (limit to 3 examples)
                const examples = unclearLinks.slice(0, 3).map(link => `"${link.linkText || 'No text'}" (page ${link.page})`).join('; ');

                return {
                    passed: false,
                    issue: IssueFactory.createIssue(
                        "WCAG 2.4.4 Link Purpose (In Context) (Level A)",
                        `PDF document contains hyperlinks that lack meaningful descriptive text. Examples: ${examples}`,
                        "Screen readers announce link text to blind users. When links display raw URLs or generic text like 'click here', blind users cannot determine the link's purpose or destination without exploring it, making navigation inefficient and potentially confusing.",
                        "Associate each hyperlink with descriptive text that clearly indicates its purpose or destination. Avoid using raw URLs, page numbers, or generic phrases like 'click here' as link text."
                    )
                };
            }

            // No issues found
            return { passed: true };
        } catch (error) {
            console.error('Error testing link purpose:', error);
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    "WCAG 2.4.4 Link Purpose (In Context) (Level A)",
                    error as Error,
                    "Unable to determine if hyperlinks have meaningful descriptive text",
                    "Ensure the PDF file is valid and accessible, with proper tagging of hyperlinks and associated text"
                )
            };
        }
    }

    /**
     * Tests if images in a PDF document have alternative text (WCAG 1.1.1)
     * @param pdfDoc PDF document
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testImageAltText(pdfDoc: pdfjsLib.PDFDocumentProxy): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            // Extract image content from all pages
            const images: ImageContent[] = [];

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);

                // Extract images from the page
                const imageExtractionResult = await ImageExtractor.extractImagesFromPage(page, pageNum);

                images.push(...imageExtractionResult);
            }

            // If there are no images, this criterion doesn't apply
            if (images.length === 0) {
                console.log("Document doesn't contain any images, WCAG 1.1.1 criterion for images doesn't apply");
                return { passed: true };
            }

            // Check for images without alt text
            const imagesWithoutAltText = images.filter(image => !image.hasAltText);

            // If we found images without alt text
            if (imagesWithoutAltText.length > 0) {
                return {
                    passed: false,
                    issue: IssueFactory.createIssue(
                        "WCAG 1.1.1 Non-text Content (Level A)",
                        `PDF document contains ${imagesWithoutAltText.length} image${imagesWithoutAltText.length === 1 ? '' : 's'} without alternative text on page${imagesWithoutAltText.length === 1 ? '' : 's'} ${imagesWithoutAltText.map(img => img.page).join(', ')}`,
                        "Screen readers cannot convey the content or purpose of these images to blind users, potentially causing them to miss important information conveyed visually",
                        "Add appropriate alternative text to all images in the PDF structure. The alt text should convey the purpose and content of each image in a concise manner."
                    )
                };
            }

            // No issues found
            return { passed: true };
        } catch (error) {
            console.error('Error testing image alt text:', error);
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    "WCAG 1.1.1 Non-text Content (Level A)",
                    error as Error,
                    "Unable to determine if images have alternative text",
                    "Ensure the PDF file is valid and accessible, with proper tagging of images and alternative text"
                )
            };
        }
    }

    /**
     * Tests if all form fields in a PDF document have labels (WCAG 3.3.2)
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an object with test result and optional issue
     */
    static async testFormFieldLabels(pdfPath: string): Promise<{ passed: boolean; issue?: AccessibilityIssue }> {
        try {
            const pdfLoader = new PdfLoader();
            const pdfDoc = await PdfLoader.loadWithPdfLib(pdfPath);
            const form = pdfDoc.getForm();
            const fields = form.getFields();
            
            const fieldsWithoutLabels = fields.filter(field => {
                // Check for TU (tooltip/user-facing label) entry in the field dictionary
                const dict = (field as any).acroField.dict;
                return !dict.has('TU');
            });

            if (fieldsWithoutLabels.length === 0) {
                return { passed: true };
            }

            const fieldNames = fieldsWithoutLabels.map(field => field.getName()).join(', ');
            return {
                passed: false,
                issue: IssueFactory.createIssue(
                    'WCAG 3.3.2 Labels or Instructions (Level A)',
                    `Found ${fieldsWithoutLabels.length} form fields without labels: ${fieldNames}`,
                    'Critical',
                    'Add labels to all form fields using the TU (tooltip) entry in the field dictionary. This ensures that users understand what information is required for each field.'
                )
            };
        } catch (error) {
            return {
                passed: false,
                issue: IssueFactory.createErrorIssue(
                    'WCAG 3.3.2 Labels or Instructions (Level A)',
                    error as Error,
                    'Critical',
                    'Unable to check form field labels. Ensure the PDF is not encrypted and is a valid form.'
                )
            };
        }
    }

    /**
     * Extracts form fields in the tab order specified in the PDF metadata
     * This is useful for analyzing keyboard navigation and focus order
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an array of objects containing field info and position
     */
    static async extractFormFieldsInTabOrder(pdfPath: string): Promise<Array<{
        name: string;
        type: string;
        page: number;
        rect: { x: number; y: number; width: number; height: number };
        hasLabel: boolean;
        tabIndex?: number;
    }>> {
        try {
            const pdfDoc = await PdfLoader.loadWithPdfLib(pdfPath);
            const form = pdfDoc.getForm();
            const fields = form.getFields();
            
            const fieldPositions = await Promise.all(fields.map(async (field, index) => {
                const dict = (field as any).acroField.dict;
                const rect = dict.lookup('Rect')?.asArray()?.map((x: any) => x.asNumber()) || [0, 0, 0, 0];
                const pageRef = dict.lookup('P'); // Get the page reference
                const pageIndex = pageRef ? pdfDoc.getPages().findIndex(page => page.ref === pageRef) : 0;
                
                // Try to get tab order from the field dictionary
                // Tab order can be specified in different ways depending on the PDF:
                // 1. Through a 'TI' (Tab Index) entry in the field dictionary
                // 2. Through the field's position in the document's tab order array
                // 3. Through a 'Tabs' entry in the page dictionary
                let tabIndex: number | undefined = undefined;
                
                // Check for explicit tab index in field dictionary
                if (dict.has('TI')) {
                    tabIndex = dict.lookup('TI')?.asNumber();
                }
                
                // If no explicit tab index, use the field's index in the form fields array
                if (tabIndex === undefined) {
                    tabIndex = index;
                }
                
                return {
                    name: field.getName(),
                    type: field.constructor.name.replace('PDFField', ''),
                    page: pageIndex,
                    rect: {
                        x: rect[0],
                        y: rect[1],
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1]
                    },
                    hasLabel: dict.has('TU'),
                    tabIndex
                };
            }));

            // Sort fields by tab index
            return fieldPositions.sort((a, b) => {
                // First sort by page
                if (a.page !== b.page) return a.page - b.page;
                
                // Then sort by tab index if available
                if (a.tabIndex !== undefined && b.tabIndex !== undefined) {
                    return a.tabIndex - b.tabIndex;
                }
                
                // Fall back to physical order if tab index is not available
                if (Math.abs(a.rect.y - b.rect.y) > 10) return b.rect.y - a.rect.y;
                return a.rect.x - b.rect.x;
            });
        } catch (error) {
            console.error('Error extracting form fields in tab order:', error);
            return [];
        }
    }

    /**
     * Helper function to extract form fields in their physical order on the page
     * This is useful for analyzing focus order and meaningful sequence
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an array of objects containing field info and position
     */
    static async extractFormFieldsInPhysicalOrder(pdfPath: string): Promise<Array<{
        name: string;
        type: string;
        page: number;
        rect: { x: number; y: number; width: number; height: number };
        hasLabel: boolean;
    }>> {
        try {
            const pdfDoc = await PdfLoader.loadWithPdfLib(pdfPath);
            const form = pdfDoc.getForm();
            const fields = form.getFields();
            
            const fieldPositions = await Promise.all(fields.map(async field => {
                const dict = (field as any).acroField.dict;
                const rect = dict.lookup('Rect')?.asArray()?.map((x: any) => x.asNumber()) || [0, 0, 0, 0];
                const pageRef = dict.lookup('P'); // Get the page reference
                const pageIndex = pageRef ? pdfDoc.getPages().findIndex(page => page.ref === pageRef) : 0;
                
                return {
                    name: field.getName(),
                    type: field.constructor.name.replace('PDFField', ''),
                    page: pageIndex,
                    rect: {
                        x: rect[0],
                        y: rect[1],
                        width: rect[2] - rect[0],
                        height: rect[3] - rect[1]
                    },
                    hasLabel: dict.has('TU')
                };
            }));

            // Sort fields by page number first, then by y-coordinate (top to bottom),
            // and finally by x-coordinate (left to right)
            return fieldPositions.sort((a, b) => {
                if (a.page !== b.page) return a.page - b.page;
                if (Math.abs(a.rect.y - b.rect.y) > 10) return b.rect.y - a.rect.y; // Reverse y-order since PDF coordinates start from bottom
                return a.rect.x - b.rect.x;
            });
        } catch (error) {
            console.error('Error extracting form fields:', error);
            return [];
        }
    }

    /**
     * Determines whether a PDF file is a form or a regular document
     * @param pdfPath Path to the PDF file
     * @returns Object containing isForm, isDocument flags, confidence level, and details
     */
    static async detectDocumentType(pdfPath: string): Promise<{
        isForm: boolean;
        isDocument: boolean;
        confidence: number;
        details: string[];
    }> {
        try {
            // Default result structure - assume it's a document until proven otherwise
            const result = {
                isForm: false,
                isDocument: true,
                confidence: 100, // Always 100% confidence in our binary classification
                details: [] as string[]
            };
            
            // Check if the PDF is encrypted - this can affect our ability to detect forms
            const isEncrypted = await PdfLoader.isEncrypted(pdfPath);
            
            // IMPORTANT: Encrypted PDFs require special consideration
            // Some encrypted PDFs may be forms but standard detection methods might fail because:
            // 1. The encryption may prevent pdf-lib from accessing form fields
            // 2. The encryption may block pdf.js from reading annotations
            // 3. The encryption level and permissions affect which operations are allowed
            // Strategy: We try multiple detection methods (pdf-lib first, then pdf.js)
            // and fall back to treating it as a regular document if both methods fail
            
            // STEP 1: Try to detect form fields using pdf-lib
            // This is the primary and most reliable method for detecting forms
            try {
                const pdfLibDoc = await PdfLoader.loadWithPdfLib(pdfPath);
                const form = pdfLibDoc.getForm();
                const fields = form.getFields();
                
                // If any fields are found, it's definitely a form
                if (fields.length > 0) {
                    result.isForm = true;
                    result.isDocument = false;
                    result.confidence = 100;
                    result.details.push(`Found ${fields.length} form fields`);
                    return result;
                }
            } catch (pdfLibError) {
                // pdf-lib may fail for encrypted PDFs or PDFs with certain security settings
                // In this case, we'll try the alternative method using pdf.js
                result.details.push(`Could not check for form fields with pdf-lib: ${(pdfLibError as Error).message}`);
            }
            
            // STEP 2: If no fields found with pdf-lib, try with pdf.js for form annotations
            // This is our backup method for detecting forms when pdf-lib fails
            const pdfJsDoc = await PdfLoader.loadWithPdfJs(pdfPath);
            let hasFormAnnotations = false;
            
            for (let i = 1; i <= pdfJsDoc.numPages; i++) {
                const page = await pdfJsDoc.getPage(i);
                
                // Get the structure tree for this page if available
                let structTreeRoot;
                try {
                    // The structure tree contains semantic information including headings
                    structTreeRoot = await page.getStructTree();
                } catch (error) {
                    console.warn(`No structure tree available for page ${i}:`, error);
                    continue;
                }
                
                if (structTreeRoot) {
                    // Extract headings from the structure tree
                    this.processStructNode(structTreeRoot, [], i, 1);
                } else {
                    // Fallback: try to identify headings based on text styling
                    // This is less reliable but can work when structure tree is not available
                    const textContent = await page.getTextContent();
                    this.identifyHeadingsFromTextContent(textContent, [], i);
                }
            }
            
            // Sort headings by page number first, then by y-coordinate (top to bottom),
            // and finally by x-coordinate (left to right)
            return headings.sort((a, b) => {
                if (a.page !== b.page) return a.page - b.page;
                if (Math.abs(a.rect.y - b.rect.y) > 10) return b.rect.y - a.rect.y; // Reverse y-order since PDF coordinates start from bottom
                return a.rect.x - b.rect.x;
            });
        } catch (error) {
            console.error('Error extracting document headings:', error);
            return [];
        }
    }
    
    /**
     * Recursively processes structure tree nodes to find headings
     * @param node Structure tree node
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     * @param currentLevel Current heading level (for nested headings)
     */
    private static processStructNode(
        node: any, 
        headings: Array<{ text: string; level: number; page: number }>,
        pageNum: number,
        currentLevel: number
    ): void {
        if (!node) return;
        
        // Check if this node is a heading
        if (node.role === 'heading' || (node.role === 'H' && node.children)) {
            // Try to determine heading level
            let level = currentLevel;
            
            // Check if there's an explicit heading level
            if (node.attributes && node.attributes.Level) {
                level = parseInt(node.attributes.Level, 10);
            } else if (node.role && node.role.length > 1 && node.role.startsWith('H')) {
                // Handle cases like H1, H2, etc.
                const levelMatch = node.role.match(/H(\d+)/);
                if (levelMatch && levelMatch[1]) {
                    level = parseInt(levelMatch[1], 10);
                }
            }
            
            // Extract text content from this heading node
            let headingText = '';
            if (node.children) {
                headingText = this.extractTextFromStructNode(node);
            }
            
            // Only add non-empty headings
            if (headingText.trim()) {
                headings.push({
                    text: headingText.trim(),
                    level: level,
                    page: pageNum
                });
            }
        }
        
        // Process child nodes recursively
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                this.processStructNode(child, headings, pageNum, currentLevel);
            }
        }
    }
    
    /**
     * Extracts text content from a structure tree node
     * @param node Structure tree node
     * @returns Extracted text
     */
    private static extractTextFromStructNode(node: any): string {
        if (!node) return '';
        
        // If this is a text node, return its content
        if (node.str) return node.str;
        
        // If this node has children, concatenate their text
        let text = '';
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                text += this.extractTextFromStructNode(child);
            }
        }
        
        return text;
    }
    
    /**
     * Identifies headings based on text styling when structure tree is not available
     * This is a fallback method that uses heuristics to identify headings
     * @param textContent Text content from pdf.js
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     */
    private static identifyHeadingsFromTextContent(
        textContent: any,
        headings: Array<{ text: string; level: number; page: number }>,
        pageNum: number
    ): void {
        if (!textContent || !textContent.items || !Array.isArray(textContent.items)) {
            return;
        }
        
        // Group text items by their y-position to identify lines
        const lines: { [key: number]: Array<any> } = {};
        for (const item of textContent.items) {
            // Round y position to group nearby items
            const yPos = Math.round(item.transform[5]);
            if (!lines[yPos]) {
                lines[yPos] = [];
            }
            lines[yPos].push(item);
        }
        
        // Sort lines by y-position (top to bottom)
        const sortedYPositions = Object.keys(lines).map(Number).sort((a, b) => b - a);
        
        // Process each line
        let prevFontSize = 0;
        for (const yPos of sortedYPositions) {
            // Sort items in this line by x-position (left to right)
            const lineItems = lines[yPos].sort((a: any, b: any) => a.transform[4] - b.transform[4]);
            
            // Combine text in this line
            const lineText = lineItems.map((item: any) => item.str).join('').trim();
            if (!lineText) continue;
            
            // Get font size of first item in line (assuming consistent styling in a heading)
            const fontSize = lineItems[0].height || 0;
            
            // Heuristic: Headings are typically larger than surrounding text
            // and often shorter in length
            if (fontSize > prevFontSize && lineText.length < 100) {
                // Estimate heading level based on font size
                // Larger fonts = lower heading levels (h1, h2)
                // This is a very rough heuristic
                const estimatedLevel = fontSize > 16 ? 1 : 
                                      fontSize > 14 ? 2 : 
                                      fontSize > 12 ? 3 : 4;
                
                headings.push({
                    text: lineText,
                    level: estimatedLevel,
                    page: pageNum
                });
            }
            
            prevFontSize = fontSize;
        }
    }
    
    /**
     * Extracts headings from PDF documents ordered by tab order as specified in PDF metadata
     * This is useful for analyzing keyboard navigation through document structure
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an array of heading objects ordered by tab sequence
     */
    static async extractDocumentHeadingsInTabOrder(pdfPath: string): Promise<Array<{
        text: string;
        level: number;
        page: number;
        tabIndex?: number;
    }>> {
        try {
            // First check if this is a form - we only want to extract headings from non-form documents
            const docType = await this.detectDocumentType(pdfPath);
            if (docType.isForm) {
                console.log('Document is a form, skipping heading extraction');
                return [];
            }

            const headings: Array<{ text: string; level: number; page: number; tabIndex?: number }> = [];
            const pdfDoc = await PdfLoader.loadWithPdfJs(pdfPath);
            
            // Process each page
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                
                // Get the structure tree for this page if available
                let structTreeRoot;
                try {
                    structTreeRoot = await page.getStructTree();
                } catch (error) {
                    console.warn(`No structure tree available for page ${i}:`, error);
                    continue;
                }
                
                if (structTreeRoot) {
                    // Extract headings from the structure tree with tab order information
                    let tabIndex = 0;
                    this.extractHeadingsWithTabOrder(structTreeRoot, headings, i, 1, tabIndex);
                } else {
                    // Fallback: try to identify headings based on text styling
                    const textContent = await page.getTextContent();
                    this.identifyHeadingsWithTabOrder(textContent, headings, i);
                }
            }
            
            // Sort headings by tab order if available, otherwise by page and position
            return headings.sort((a, b) => {
                // First sort by page number
                if (a.page !== b.page) return a.page - b.page;
                
                // Then sort by tab index if available
                if (a.tabIndex !== undefined && b.tabIndex !== undefined) {
                    return a.tabIndex - b.tabIndex;
                }
                
                // If no tab index, maintain the order they were found in (which is typically reading order)
                return 0;
            });
        } catch (error) {
            console.error('Error extracting document headings in tab order:', error);
            return [];
        }
    }
    
    /**
     * Helper method to extract headings with tab order information from structure tree
     * @param node Structure tree node
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     * @param level Current heading level
     * @param tabIndex Current tab index counter
     * @returns Updated tab index counter
     */
    private static extractHeadingsWithTabOrder(
        node: any, 
        headings: Array<{ text: string; level: number; page: number; tabIndex?: number }>,
        pageNum: number,
        level: number,
        tabIndex: number
    ): number {
        if (!node) return tabIndex;
        
        // Check if this node is a heading
        if (node.role === 'heading' || (node.role === 'H' && node.children)) {
            // Try to determine heading level
            let headingLevel = level;
            
            // Check if there's an explicit heading level
            if (node.attributes && node.attributes.Level) {
                headingLevel = parseInt(node.attributes.Level, 10);
            } else if (node.role && node.role.length > 1 && node.role.startsWith('H')) {
                // Handle cases like H1, H2, etc.
                const levelMatch = node.role.match(/H(\d+)/);
                if (levelMatch && levelMatch[1]) {
                    headingLevel = parseInt(levelMatch[1], 10);
                }
            }
            
            // Try to get tab order information
            let headingTabIndex: number | undefined = undefined;
            
            // Check for explicit tab index in node attributes
            if (node.attributes && node.attributes.TI) {
                headingTabIndex = parseInt(node.attributes.TI, 10);
            } else if (node.attributes && node.attributes.TabIndex) {
                headingTabIndex = parseInt(node.attributes.TabIndex, 10);
            } else {
                // If no explicit tab index, use the current counter
                headingTabIndex = tabIndex++;
            }
            
            // Extract text content from this heading node
            let headingText = '';
            if (node.children) {
                headingText = this.extractTextFromStructNode(node);
            }
            
            // Only add non-empty headings
            if (headingText.trim()) {
                headings.push({
                    text: headingText.trim(),
                    level: headingLevel,
                    page: pageNum,
                    tabIndex: headingTabIndex
                });
            }
        }
        
        // Process child nodes recursively, updating the tab index counter
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                tabIndex = this.extractHeadingsWithTabOrder(child, headings, pageNum, level, tabIndex);
            }
        }
        
        return tabIndex;
    }
    
    /**
     * Helper method to identify headings with tab order from text content
     * @param textContent Text content from pdf.js
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     */
    private static identifyHeadingsWithTabOrder(
        textContent: any,
        headings: Array<{ text: string; level: number; page: number; tabIndex?: number }>,
        pageNum: number
    ): void {
        if (!textContent || !textContent.items || !Array.isArray(textContent.items)) {
            return;
        }
        
        // Group text items by their y-position to identify lines
        const lines: { [key: number]: Array<any> } = {};
        for (const item of textContent.items) {
            // Round y position to group nearby items
            const yPos = Math.round(item.transform[5]);
            if (!lines[yPos]) {
                lines[yPos] = [];
            }
            lines[yPos].push(item);
        }
        
        // Sort lines by y-position (top to bottom)
        const sortedYPositions = Object.keys(lines).map(Number).sort((a, b) => b - a);
        
        // Process each line
        let prevFontSize = 0;
        let tabIndex = 0;
        
        for (const yPos of sortedYPositions) {
            // Sort items in this line by x-position (left to right)
            const lineItems = lines[yPos].sort((a: any, b: any) => a.transform[4] - b.transform[4]);
            
            // Combine text in this line
            const lineText = lineItems.map((item: any) => item.str).join('').trim();
            if (!lineText) continue;
            
            // Get font size of first item in line (assuming consistent styling in a heading)
            const fontSize = lineItems[0].height || 0;
            
            // Heuristic: Headings are typically larger than surrounding text
            // and often shorter in length
            if (fontSize > prevFontSize && lineText.length < 100) {
                // Estimate heading level based on font size
                // Larger fonts = lower heading levels (h1, h2)
                // This is a very rough heuristic
                const estimatedLevel = fontSize > 16 ? 1 : 
                                      fontSize > 14 ? 2 : 
                                      fontSize > 12 ? 3 : 4;
                
                headings.push({
                    text: lineText,
                    level: estimatedLevel,
                    page: pageNum,
                    tabIndex: tabIndex++
                });
            }
            
            prevFontSize = fontSize;
        }
    }

    /**
     * Placeholder function for testing WCAG 2.4.3 Focus Order compliance
     * This criterion ensures that the order of focus when navigating through interactive elements
     * is logical and intuitive for keyboard and screen reader users
     * @returns Information about the pending test
     */
    static getPendingFocusOrderTest(): PendingTest {
        return {
            criterion: "WCAG 2.4.3 Focus Order (Level A)",
            reason: "We are planning to implement this test. This criterion ensures that the order of focus when navigating through interactive elements in a PDF (like form fields and links) follows a sequence that preserves meaning and operability. This is essential for blind users who navigate documents using keyboard commands with screen readers.",
            status: "Planned - Requirements Analysis"
        };
    }

    /**
     * Placeholder function for testing WCAG 1.3.2 Meaningful Sequence compliance
     * This criterion ensures that the reading order of content is logical and matches
     * the visual presentation, which is critical for screen reader users
     * @returns Information about the pending test
     */
    static getPendingMeaningfulSequenceTest(): PendingTest {
        return {
            criterion: "WCAG 1.3.2 Meaningful Sequence (Level A)",
            reason: "We are planning to implement this test. This criterion ensures that when the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined. For PDFs, this involves checking the document's structure tree and reading order.",
            status: "Planned - Requirements Analysis"
        };
    }

    /**
     * Placeholder function for testing WCAG 2.4.5 Multiple Ways compliance
     * This criterion requires that there is more than one way to locate a webpage within a set of webpages
     * For PDFs, this would involve checking for the presence of bookmarks, a table of contents, or other navigation aids
     * @returns Information about the pending test
     */
    static getPendingMultipleWaysTest(): PendingTest {
        return {
            criterion: "WCAG 2.4.5 Multiple Ways (Level AA)",
            reason: "We are planning to implement this test. This criterion requires that there is more than one way to locate a webpage within a set of webpages. For PDFs, this would involve checking for the presence of bookmarks, a table of contents, or other navigation aids.",
            status: "Planned - Requirements Analysis"
        };
    }

    /**
     * Finds text in a different language than the document default
     * @param textContents Array of TextContent objects
     * @param defaultLang Default language code
     * @returns Array of TextContent objects in a different language
     */
    static findTextInDifferentLanguage(textContents: TextContent[], defaultLang: string): TextContent[] {
        return textContents.filter(content => {
            // Skip empty or very short text
            if (!content.text || content.text.trim().length < 10) {
                return false;
            }
            
            // If the text has a language tag, check if it's different from the default
            if (content.detectedLang && content.detectedLang !== defaultLang) {
                return true;
            }
            
            return false;
        });
    }

    /**
     * Formats text examples for the accessibility issue description
     * @param texts Array of TextContent objects
     * @param limit Maximum number of examples to include
     * @returns Formatted string of examples
     */
    static formatTextExamples(texts: TextContent[], limit: number = 3): string {
        return texts.slice(0, limit).map(content => {
            // Truncate long text
            let text = content.text;
            if (text.length > 50) {
                text = text.substring(0, 47) + '...';
            }
            
            return `"${text}" (page ${content.page}, detected language: ${content.detectedLang || 'unknown'})`;
        }).join(', ');
    }
    
    /**
     * Extracts headings from PDF documents that are not forms
     * Returns an array of headings with their text content, level, and page number
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an array of heading objects
     */
    static async extractDocumentHeadings(pdfPath: string): Promise<Array<{
        text: string;
        level: number;
        page: number;
    }>> {
        try {
            // First check if this is a form - we only want to extract headings from non-form documents
            const docType = await this.detectDocumentType(pdfPath);
            if (docType.isForm) {
                console.log('Document is a form, skipping heading extraction');
                return [];
            }

            const headings: Array<{ text: string; level: number; page: number }> = [];
            const pdfDoc = await PdfLoader.loadWithPdfJs(pdfPath);
            
            // Process each page
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                
                // Get the structure tree for this page if available
                let structTreeRoot;
                try {
                    // The structure tree contains semantic information including headings
                    structTreeRoot = await page.getStructTree();
                } catch (error) {
                    console.warn(`No structure tree available for page ${i}:`, error);
                    continue;
                }
                
                if (structTreeRoot) {
                    // Extract headings from the structure tree
                    this.processStructNode(structTreeRoot, headings, i, 1);
                } else {
                    // Fallback: try to identify headings based on text styling
                    // This is less reliable but can work when structure tree is not available
                    const textContent = await page.getTextContent();
                    this.identifyHeadingsFromTextContent(textContent, headings, i);
                }
            }
            
            return headings;
        } catch (error) {
            console.error('Error extracting document headings:', error);
            return [];
        }
    }
    
    /**
     * Recursively processes structure tree nodes to find headings
     * @param node Structure tree node
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     * @param currentLevel Current heading level (for nested headings)
     */
    private static processStructNode(
        node: any, 
        headings: Array<{ text: string; level: number; page: number }>,
        pageNum: number,
        currentLevel: number
    ): void {
        if (!node) return;
        
        // Check if this node is a heading
        if (node.role === 'heading' || (node.role === 'H' && node.children)) {
            // Try to determine heading level
            let level = currentLevel;
            
            // Check if there's an explicit heading level
            if (node.attributes && node.attributes.Level) {
                level = parseInt(node.attributes.Level, 10);
            } else if (node.role && node.role.length > 1 && node.role.startsWith('H')) {
                // Handle cases like H1, H2, etc.
                const levelMatch = node.role.match(/H(\d+)/);
                if (levelMatch && levelMatch[1]) {
                    level = parseInt(levelMatch[1], 10);
                }
            }
            
            // Extract text content from this heading node
            let headingText = '';
            if (node.children) {
                headingText = this.extractTextFromStructNode(node);
            }
            
            // Only add non-empty headings
            if (headingText.trim()) {
                headings.push({
                    text: headingText.trim(),
                    level: level,
                    page: pageNum
                });
            }
        }
        
        // Process child nodes recursively
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                this.processStructNode(child, headings, pageNum, currentLevel);
            }
        }
    }
    
    /**
     * Extracts text content from a structure tree node
     * @param node Structure tree node
     * @returns Extracted text
     */
    private static extractTextFromStructNode(node: any): string {
        if (!node) return '';
        
        // If this is a text node, return its content
        if (node.str) return node.str;
        
        // If this node has children, concatenate their text
        let text = '';
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                text += this.extractTextFromStructNode(child);
            }
        }
        
        return text;
    }
    
    /**
     * Identifies headings based on text styling when structure tree is not available
     * This is a fallback method that uses heuristics to identify headings
     * @param textContent Text content from pdf.js
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     */
    private static identifyHeadingsFromTextContent(
        textContent: any,
        headings: Array<{ text: string; level: number; page: number }>,
        pageNum: number
    ): void {
        if (!textContent || !textContent.items || !Array.isArray(textContent.items)) {
            return;
        }
        
        // Group text items by their y-position to identify lines
        const lines: { [key: number]: Array<any> } = {};
        for (const item of textContent.items) {
            // Round y position to group nearby items
            const yPos = Math.round(item.transform[5]);
            if (!lines[yPos]) {
                lines[yPos] = [];
            }
            lines[yPos].push(item);
        }
        
        // Sort lines by y-position (top to bottom)
        const sortedYPositions = Object.keys(lines).map(Number).sort((a, b) => b - a);
        
        // Process each line
        let prevFontSize = 0;
        for (const yPos of sortedYPositions) {
            // Sort items in this line by x-position (left to right)
            const lineItems = lines[yPos].sort((a: any, b: any) => a.transform[4] - b.transform[4]);
            
            // Combine text in this line
            const lineText = lineItems.map((item: any) => item.str).join('').trim();
            if (!lineText) continue;
            
            // Get font size of first item in line (assuming consistent styling in a heading)
            const fontSize = lineItems[0].height || 0;
            
            // Heuristic: Headings are typically larger than surrounding text
            // and often shorter in length
            if (fontSize > prevFontSize && lineText.length < 100) {
                // Estimate heading level based on font size
                // Larger fonts = lower heading levels (h1, h2)
                // This is a very rough heuristic
                const estimatedLevel = fontSize > 16 ? 1 : 
                                      fontSize > 14 ? 2 : 
                                      fontSize > 12 ? 3 : 4;
                
                headings.push({
                    text: lineText,
                    level: estimatedLevel,
                    page: pageNum
                });
            }
            
            prevFontSize = fontSize;
        }
    }
    
    /**
     * Extracts headings from PDF documents ordered by tab order as specified in PDF metadata
     * This is useful for analyzing keyboard navigation through document structure
     * @param pdfPath Path to the PDF file
     * @returns Promise resolving to an array of heading objects ordered by tab sequence
     */
    static async extractDocumentHeadingsInTabOrder(pdfPath: string): Promise<Array<{
        text: string;
        level: number;
        page: number;
        tabIndex?: number;
    }>> {
        try {
            // First check if this is a form - we only want to extract headings from non-form documents
            const docType = await this.detectDocumentType(pdfPath);
            if (docType.isForm) {
                console.log('Document is a form, skipping heading extraction');
                return [];
            }

            const headings: Array<{ text: string; level: number; page: number; tabIndex?: number }> = [];
            const pdfDoc = await PdfLoader.loadWithPdfJs(pdfPath);
            
            // Process each page
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                
                // Get the structure tree for this page if available
                let structTreeRoot;
                try {
                    structTreeRoot = await page.getStructTree();
                } catch (error) {
                    console.warn(`No structure tree available for page ${i}:`, error);
                    continue;
                }
                
                if (structTreeRoot) {
                    // Extract headings from the structure tree with tab order information
                    let tabIndex = 0;
                    this.extractHeadingsWithTabOrder(structTreeRoot, headings, i, 1, tabIndex);
                } else {
                    // Fallback: try to identify headings based on text styling
                    const textContent = await page.getTextContent();
                    this.identifyHeadingsWithTabOrder(textContent, headings, i);
                }
            }
            
            // Sort headings by tab order if available, otherwise by page and position
            return headings.sort((a, b) => {
                // First sort by page number
                if (a.page !== b.page) return a.page - b.page;
                
                // Then sort by tab index if available
                if (a.tabIndex !== undefined && b.tabIndex !== undefined) {
                    return a.tabIndex - b.tabIndex;
                }
                
                // If no tab index, maintain the order they were found in (which is typically reading order)
                return 0;
            });
        } catch (error) {
            console.error('Error extracting document headings in tab order:', error);
            return [];
        }
    }
    
    /**
     * Helper method to extract headings with tab order information from structure tree
     * @param node Structure tree node
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     * @param level Current heading level
     * @param tabIndex Current tab index counter
     * @returns Updated tab index counter
     */
    private static extractHeadingsWithTabOrder(
        node: any, 
        headings: Array<{ text: string; level: number; page: number; tabIndex?: number }>,
        pageNum: number,
        level: number,
        tabIndex: number
    ): number {
        if (!node) return tabIndex;
        
        // Check if this node is a heading
        if (node.role === 'heading' || (node.role === 'H' && node.children)) {
            // Try to determine heading level
            let headingLevel = level;
            
            // Check if there's an explicit heading level
            if (node.attributes && node.attributes.Level) {
                headingLevel = parseInt(node.attributes.Level, 10);
            } else if (node.role && node.role.length > 1 && node.role.startsWith('H')) {
                // Handle cases like H1, H2, etc.
                const levelMatch = node.role.match(/H(\d+)/);
                if (levelMatch && levelMatch[1]) {
                    headingLevel = parseInt(levelMatch[1], 10);
                }
            }
            
            // Try to get tab order information
            let headingTabIndex: number | undefined = undefined;
            
            // Check for explicit tab index in node attributes
            if (node.attributes && node.attributes.TI) {
                headingTabIndex = parseInt(node.attributes.TI, 10);
            } else if (node.attributes && node.attributes.TabIndex) {
                headingTabIndex = parseInt(node.attributes.TabIndex, 10);
            } else {
                // If no explicit tab index, use the current counter
                headingTabIndex = tabIndex++;
            }
            
            // Extract text content from this heading node
            let headingText = '';
            if (node.children) {
                headingText = this.extractTextFromStructNode(node);
            }
            
            // Only add non-empty headings
            if (headingText.trim()) {
                headings.push({
                    text: headingText.trim(),
                    level: headingLevel,
                    page: pageNum,
                    tabIndex: headingTabIndex
                });
            }
        }
        
        // Process child nodes recursively, updating the tab index counter
        if (node.children && Array.isArray(node.children)) {
            for (const child of node.children) {
                tabIndex = this.extractHeadingsWithTabOrder(child, headings, pageNum, level, tabIndex);
            }
        }
        
        return tabIndex;
    }
    
    /**
     * Helper method to identify headings with tab order from text content
     * @param textContent Text content from pdf.js
     * @param headings Array to collect heading information
     * @param pageNum Current page number
     */
    private static identifyHeadingsWithTabOrder(
        textContent: any,
        headings: Array<{ text: string; level: number; page: number; tabIndex?: number }>,
        pageNum: number
    ): void {
        if (!textContent || !textContent.items || !Array.isArray(textContent.items)) {
            return;
        }
        
        // Group text items by their y-position to identify lines
        const lines: { [key: number]: Array<any> } = {};
        for (const item of textContent.items) {
            // Round y position to group nearby items
            const yPos = Math.round(item.transform[5]);
            if (!lines[yPos]) {
                lines[yPos] = [];
            }
            lines[yPos].push(item);
        }
        
        // Sort lines by y-position (top to bottom)
        const sortedYPositions = Object.keys(lines).map(Number).sort((a, b) => b - a);
        
        // Process each line
        let prevFontSize = 0;
        let tabIndex = 0;
        
        for (const yPos of sortedYPositions) {
            // Sort items in this line by x-position (left to right)
            const lineItems = lines[yPos].sort((a: any, b: any) => a.transform[4] - b.transform[4]);
            
            // Combine text in this line
            const lineText = lineItems.map((item: any) => item.str).join('').trim();
            if (!lineText) continue;
            
            // Get font size of first item in line (assuming consistent styling in a heading)
            const fontSize = lineItems[0].height || 0;
            
            // Heuristic: Headings are typically larger than surrounding text
            // and often shorter in length
            if (fontSize > prevFontSize && lineText.length < 100) {
                // Estimate heading level based on font size
                // Larger fonts = lower heading levels (h1, h2)
                // This is a very rough heuristic
                const estimatedLevel = fontSize > 16 ? 1 : 
                                      fontSize > 14 ? 2 : 
                                      fontSize > 12 ? 3 : 4;
                
                headings.push({
                    text: lineText,
                    level: estimatedLevel,
                    page: pageNum,
                    tabIndex: tabIndex++
                });
            }
            
            prevFontSize = fontSize;
        }
    }

    /**
     * Placeholder function for testing WCAG 2.4.3 Focus Order compliance
{{ ... }}
